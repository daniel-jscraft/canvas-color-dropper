<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            border: 2px solid red;
        }

        img {
            display: none;
        }
        input {
            display: block;
        }
    </style>
</head>
<body>
    <input id="file-picker" type='file' accept='image/*' capture='camera' value="/Users/danielnastase/Downloads/canvas-color-dropper/sample.png"/>
    <canvas id="canvas"></canvas>
    <img id="img" />
<script>

const TOOL_RADIUS = 40

const canvas = document.querySelector('#canvas')
const canvasContext = canvas.getContext("2d")
const filePicker = document.querySelector('#file-picker')
const img = document.querySelector('#img')

let pixels = []
let imgData = null

filePicker.addEventListener('change', () => {
    console.log(filePicker.files[0])
    const url = window.URL.createObjectURL(filePicker.files[0])
    img.src = url
})

img.onload = ()=> {
    canvasContext.drawImage(img, 0, 0)
    imgData = canvasContext.getImageData(0, 0, canvas.width, canvas.height)
    canvasContext.putImageData(imgData, 0, 0)
    pixels = canvasContext.getImageData(0, 0, img.naturalWidth, img.naturalHeight);
}

function pixelColour(x, y) {
    const index = ((y*(pixels.width*4)) + (x*4)),
        red = pixels.data[index],
        green = pixels.data[index + 1],
        blue = pixels.data[index + 2],
        a = pixels.data[index + 3];
    return {red, green, blue, a};
}

function readColour(ev) {
    const x = ev.pageX - canvas.offsetLeft;
    const y = ev.pageY - canvas.offsetTop;
    const p = pixelColour(x, y);
    console.log(p)
    drawMagnifyingGlassCircle(x, y)
}

function eraseMagnifyingGlass() { // Called when the mouse moves
   if (imgData != null) {
    canvasContext.putImageData(imgData, 0, 0);
   }
}

function drawMagnifyingGlassCircle(x, y) {
    eraseMagnifyingGlass()

    canvasContext.save()

    canvasContext.beginPath()

    
    // canvasContext.rect(x - TOOL_RADIUS / 2, y - TOOL_RADIUS / 2, TOOL_RADIUS, TOOL_RADIUS);
    // canvasContext.fillStyle = "red";
    // canvasContext.fill();
    // canvasContext.lineWidth = 2;
    // canvasContext.strokeStyle = "black";
    // canvasContext.stroke();

    const SQUARES_NO = 3

    console.log('-----------------')
    // for (let v = y - SQUARES_NO; v < y + SQUARES_NO; v++) {
    //   for (let h = x - SQUARES_NO; h < x + SQUARES_NO; h++) {
    //     const p = pixelColour(h, v)
    //     // template literals here
    //     //console.log(p)
    //     // canvasContext.fillStyle = 'rgba(' + p.r + ', ' + p.g +', ' + p.b + ', ' + p.a / 255+')'
        
    //     console.log(
    //         {
    //             x,
    //             y,
    //             h,
    //             v,
    //             cx: x - h * (TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO )), 
    //             cy: y - v * (TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO )),
    //             wi: TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO ),
    //             he: TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO )
    //         }
    //     )
    //     canvasContext.rect(
    //         x - h * (TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO )), 
    //         y - v * (TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO )), 
    //         TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO ), 
    //         TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO )
    //     )
    //     canvasContext.fillStyle = "red";
    //     canvasContext.fill();
    //     canvasContext.lineWidth = 2;
    //     canvasContext.strokeStyle = "black";
    //     canvasContext.stroke();
    //   }
    // }



    for (let v = 0 - SQUARES_NO; v < SQUARES_NO; v++) {
      for (let h = 0 - SQUARES_NO; h < SQUARES_NO; h++) {
        const p = pixelColour(x + h, y + v)
        //template literals here
        console.log(p)
        
        canvasContext.rect(
            x - h * (TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO )), 
            y - v * (TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO )), 
            TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO ), 
            TOOL_RADIUS*2 / ( SQUARES_NO * SQUARES_NO )
        )
        canvasContext.fillStyle = 'rgba(' + p.red + ', ' + p.green +', ' + p.blue + ', ' + p.a +')';
        console.log('rgba(' + p.red + ', ' + p.green +', ' + p.blue + ', ' + p.a +')')
        canvasContext.fill();
        canvasContext.lineWidth = 1;
        canvasContext.strokeStyle = "black";
        canvasContext.stroke();
      }
    }

    // dropx.fillStyle = 'black';
    // dropx.fillRect(0,0,300,300);
    // dropx.save();
    // dropx.translate((drop.width / 2) - 35.5, (drop.height / 2) - 17);
    // for (v = y - 3; v < y + 3; v++) {
    //   for (h = x - 3; h < x + 3; h++) {
    //     p = pixelcolour(h, v);
    //     dropx.fillStyle = 'rgba(' + p.r + ', ' + p.g +', ' + 
    //                        p.b + ', ' + p.a / 255+')';
    //     dropx.fillRect((h - x) * 70, (v - y) * 35, 69, 34); 
    //   }
    // }
    // dropx.strokeStyle = 'lime';
    // dropx.lineWidth = 2.5;
    // dropx.shadowOffsetX = 2;
    // dropx.shadowOffsetY = 2;
    // dropx.shadowBlur    = 0;
    // dropx.shadowColor   = 'black';  
    // dropx.strokeRect(-1.5,-1,71.5,36);









    canvasContext.clip()
    canvasContext.stroke()
    canvasContext.restore()
}

canvas.addEventListener('mousemove', readColour, false);

</script>
</body>
</html>